\section{Grade distributions}\label{GradeDistributions}

Here we provide the program~[[grade-dist.py]], which computes the grade 
distribution for course rounds.

We will read the data in CSV form, so we need the [[csv]] module.
We read the data from standard input.
<<grades.py>>=
import argparse
import csv
import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import sys

def add_command_options(parser):
  <<add grade-dist command-line arguments to parser>>

def command(args):
  data = pd.read_csv(sys.stdin)
  <<compute the grade distributions for data based on args>>

def main():
  parser = argparse.ArgumentParser(
    help="Compute grade distributions"
    description="Compute grade distributions for course rounds")

  add_command_options(parser)
  args = parser.parse_args()
  command(args)

if __name__ == "__main__":
  main()
@

We want to group rows on various attributes.
We have one argument for selecting which attribute (column) to group by.
Then we need two more arguments to select which values should fit into which 
group.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-g", "--group-by", default="Round",
  help="The column name to group by")
parser.add_argument("-G", "--groups", nargs="+", action="append",
  help="The values of each group, groups separated by semicolon (;)")
@

The construction above lets us add [[-G]] several times.
Each time with a new group.
<<set up groups to iterate over>>=
groups = []
if args.groups:
  groups = args.groups
else:
  groups = [[group] for group in data[args.group_by].unique()]
@

\subsection{Computing the grade distributions}

Now we can compute the grade distribution for each group.
However, we might want the results in different forms: do we want the results 
normalized or as cumulative counts?
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-n", "--normalize", action="store_true", default=False,
  help="Normalize counts")
@

Then we can compute the grade distributions as follows.
<<compute the grade distributions for data based on args>>=
<<set up groups to iterate over>>

stats = pd.DataFrame(index=data.Grade.unique())

for group in groups:
  group_data = data[data[args.group_by].isin(group)]
  group_name = "+".join(group)
  stats[group_name] = group_data.groupby("Grade")["Student"].count()
  if args.normalize:
    stats[group_name] /= len(group_data.Student.unique())

stats.sort_index(inplace=True)
<<print the stats>>
@

\subsection{Outputting the stats}

We want to print the stats.
We want to print it plainly for exploration.
We also want to print a \LaTeX-formatted version for easy inclusion in 
documents.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-L", "--LaTeX", action="store_true",
  help="Print results LaTeX formatted")
@

We also want to control if we should print the transpose of the table of not.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-T", "--transpose", action="store_true",
  help="Print table transposed")
@

We also want to produce a figure to visualize the data.
We want to provide an option for the file name.
<<add grade-dist command-line arguments to parser>>=
parser.add_argument("-f", "--fig-out",
  help="Filename for saving figure of data")
@

Now, we can just check if these flags are set or not.
<<print the stats>>=
if args.transpose:
  old_stats = stats
  stats = stats.transpose()

if args.LaTeX:
  print(stats.round(3).to_latex())
else:
  print(stats.round(3))

if args.transpose:
  stats = old_stats

matplotlib.use("pgf")
matplotlib.rcParams.update({
  "pgf.texsystem": "pdflatex",
  'font.family': 'serif',
  'text.usetex': True,
  'pgf.rcfonts': False,
})

if "fig_out" in args:
  stats.plot.bar()
  plt.tight_layout()
  plt.savefig(args.fig_out)
@
